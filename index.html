<!DOCTYPE html>
<html lang="en">
<head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-L4TQZBTBBG"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-L4TQZBTBBG');
</script>

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PNG Sprite Builder and Editor</title>
<meta name="description" content="A simple and fully local sprite builder - select a folder of PNG images, and get a sprite PNG. Can also edit existing sprite. Data never leaves your computer.">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    background: #1a1a2e;
    color: #e0e0e0;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    user-select: none;
  }

  header {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 8px 16px;
    background: #16213e;
    border-bottom: 1px solid #0f3460;
    flex-shrink: 0;
  }

  header h1 {
    font-size: 16px;
    font-weight: 600;
    color: #e94560;
    margin-right: 12px;
    white-space: nowrap;
  }

  .toolbar {
    display: flex;
    align-items: center;
    gap: 6px;
    flex-wrap: wrap;
  }

  .btn {
    padding: 6px 14px;
    border: 1px solid #0f3460;
    border-radius: 4px;
    background: #16213e;
    color: #e0e0e0;
    font-size: 13px;
    cursor: pointer;
    white-space: nowrap;
    transition: background 0.15s, border-color 0.15s;
  }
  .btn:hover { background: #1a3a6e; border-color: #e94560; }
  .btn.active { background: #e94560; border-color: #e94560; color: #fff; }
  .btn.primary { background: #e94560; border-color: #e94560; color: #fff; }
  .btn.primary:hover { background: #c73650; }
  .btn:disabled { opacity: 0.4; cursor: default; pointer-events: none; }

  .separator {
    width: 1px;
    height: 24px;
    background: #0f3460;
    margin: 0 4px;
  }

  .main-area {
    flex: 1;
    display: flex;
    min-height: 0;
  }

  .sidebar {
    width: 240px;
    background: #16213e;
    border-right: 1px solid #0f3460;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    overflow-y: auto;
    flex-shrink: 0;
  }

  .panel {
    background: #1a1a2e;
    border: 1px solid #0f3460;
    border-radius: 6px;
    padding: 10px;
  }

  .panel h3 {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: #888;
    margin-bottom: 8px;
  }

  .panel p {
    font-size: 12px;
    color: #aaa;
    line-height: 1.5;
  }

  .info-row {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    padding: 2px 0;
  }
  .info-row .label { color: #888; }
  .info-row .value { color: #e0e0e0; font-variant-numeric: tabular-nums; }

  .canvas-container {
    flex: 1;
    position: relative;
    overflow: hidden;
    background: #111;
    cursor: crosshair;
  }

  #editor-canvas {
    position: absolute;
    image-rendering: pixelated;
  }

  .selection-box {
    position: absolute;
    border: 2px dashed #e94560;
    pointer-events: none;
    display: none;
    box-shadow: 0 0 0 1px rgba(0,0,0,0.5);
  }

  .selection-box.has-selection {
    display: block;
    border-style: solid;
    background: rgba(233, 69, 96, 0.08);
  }

  .selection-handles {
    position: absolute;
    display: none;
  }
  .selection-handles.visible { display: block; }

  .selection-info {
    position: absolute;
    background: rgba(22, 33, 62, 0.92);
    border: 1px solid #0f3460;
    border-radius: 4px;
    padding: 4px 8px;
    font-size: 11px;
    color: #e0e0e0;
    pointer-events: none;
    white-space: nowrap;
    display: none;
  }

  .drop-overlay {
    position: absolute;
    inset: 0;
    background: rgba(233, 69, 96, 0.15);
    border: 3px dashed #e94560;
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 100;
    font-size: 18px;
    color: #e94560;
    font-weight: 600;
  }
  .drop-overlay.visible { display: flex; }

  .empty-state {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: #555;
    gap: 12px;
  }
  .empty-state svg { opacity: 0.3; }
  .empty-state p { font-size: 14px; }
  .empty-state .hint { font-size: 12px; color: #444; }

  .zoom-controls {
    position: absolute;
    bottom: 12px;
    right: 12px;
    display: flex;
    gap: 4px;
    align-items: center;
    background: rgba(22, 33, 62, 0.9);
    border: 1px solid #0f3460;
    border-radius: 6px;
    padding: 4px;
  }
  .zoom-controls .btn { padding: 4px 8px; font-size: 12px; }
  .zoom-controls .zoom-label {
    font-size: 11px;
    min-width: 42px;
    text-align: center;
    color: #aaa;
    font-variant-numeric: tabular-nums;
  }

  .status-bar {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 4px 16px;
    background: #16213e;
    border-top: 1px solid #0f3460;
    font-size: 11px;
    color: #888;
    flex-shrink: 0;
  }

  .checkerboard {
    background-image:
      linear-gradient(45deg, #222 25%, transparent 25%),
      linear-gradient(-45deg, #222 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, #222 75%),
      linear-gradient(-45deg, transparent 75%, #222 75%);
    background-size: 16px 16px;
    background-position: 0 0, 0 8px, 8px -8px, -8px 0;
  }

  input[type="file"] { display: none; }

  .preview-thumb {
    width: 100%;
    max-height: 120px;
    object-fit: contain;
    image-rendering: pixelated;
    border: 1px solid #0f3460;
    border-radius: 4px;
    background-image:
      linear-gradient(45deg, #1a1a2e 25%, transparent 25%),
      linear-gradient(-45deg, #1a1a2e 25%, transparent 25%),
      linear-gradient(45deg, transparent 75%, #1a1a2e 75%),
      linear-gradient(-45deg, transparent 75%, #1a1a2e 75%);
    background-size: 8px 8px;
    background-position: 0 0, 0 4px, 4px -4px, -4px 0;
    margin-top: 6px;
  }

  .replace-section {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .replace-section select {
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 4px;
    color: #e0e0e0;
    padding: 4px 6px;
    font-size: 12px;
  }

  .undo-redo { display: flex; gap: 4px; }

  .builder-list {
    max-height: 200px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 3px;
  }
  .builder-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 3px 4px;
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 4px;
    font-size: 11px;
  }
  .builder-thumb {
    width: 26px;
    height: 26px;
    object-fit: contain;
    image-rendering: pixelated;
    border-radius: 2px;
    background: #111;
    flex-shrink: 0;
  }
  .builder-item-info {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
  }
  .builder-item-name {
    color: #ccc;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .builder-item-size { color: #666; font-size: 10px; }
  .builder-item-remove {
    background: none;
    border: none;
    color: #555;
    cursor: pointer;
    font-size: 16px;
    padding: 0 4px;
    line-height: 1;
    flex-shrink: 0;
  }
  .builder-item-remove:hover { color: #e94560; }
  .builder-controls {
    display: flex;
    gap: 6px;
    align-items: center;
    margin-top: 6px;
  }
  .builder-controls label { font-size: 11px; color: #888; }
  .builder-controls input[type="number"] {
    width: 48px;
    background: #16213e;
    border: 1px solid #0f3460;
    border-radius: 4px;
    color: #e0e0e0;
    padding: 3px 6px;
    font-size: 12px;
  }
  .builder-info { font-size: 11px; color: #666; margin-top: 4px; }
</style>
</head>
<body>

<header>
  <h1>In-Browser Sprite Builder</h1>
  <div class="toolbar">
    <button class="btn" id="btn-open" title="Open sprite image">Open Sprite</button>
    <div class="separator"></div>
    <div class="undo-redo">
      <button class="btn" id="btn-undo" disabled title="Undo (Ctrl+Z)">Undo</button>
      <button class="btn" id="btn-redo" disabled title="Redo (Ctrl+Y)">Redo</button>
    </div>
    <div class="separator"></div>
    <button class="btn" id="btn-replace" disabled title="Load replacement image for selection">Replace Selection</button>
    <div class="separator"></div>
    <button class="btn" id="btn-clear-sel" disabled title="Clear selection">Clear Selection</button>
    <button class="btn primary" id="btn-export" disabled title="Export as PNG">Export PNG</button>
    <div class="separator"></div>
    <button class="btn" id="btn-add-images" title="Add multiple PNG images to sprite builder">Add Images</button>
    <button class="btn" id="btn-add-folder" title="Add a folder of PNG images">Add Folder</button>
    <button class="btn primary" id="btn-generate" disabled title="Generate optimized sprite from added images">Generate Sprite</button>
    <button class="btn" id="btn-export-css" disabled title="Export CSS for the generated sprite">Export CSS</button>
  </div>
</header>

<div class="main-area">
  <aside class="sidebar">
    
    <div class="panel">
        <h3>Download <a href="/sprite_builder_native.py">sprite_builder_native.py</a> to build sprite PNG and CSS file from a folder on your machine</h3>
    </div>

    <div class="panel">
      <h3>Sprite Builder</h3>
      <div id="builder-list">
        <p style="font-size:12px;color:#555;">Add images using the toolbar buttons.</p>
      </div>
      <div class="builder-controls">
        <label for="builder-padding">Gap:</label>
        <input type="number" id="builder-padding" min="0" max="50" value="0">
        <span style="font-size:11px;color:#888;">px</span>
        <span style="flex:1"></span>
        <button class="btn" id="btn-builder-clear" disabled style="font-size:11px;padding:3px 8px;">Clear</button>
      </div>
      <div id="builder-info" class="builder-info"></div>
    </div>

    <div class="panel">
      <h3>Sprite Info</h3>
      <div id="sprite-info">
        <p>No sprite loaded.</p>
      </div>
    </div>

    <div class="panel">
      <h3>Selection</h3>
      <div id="selection-info-panel">
        <p>Click and drag on the canvas to select a region.</p>
      </div>
    </div>

    <div class="panel">
      <h3>Replacement</h3>
      <div id="replace-info-panel" class="replace-section">
        <p>Select a region first, then click <strong>Replace Selection</strong> to load a replacement image.</p>
        <label for="fit-mode" style="font-size:12px;color:#888;margin-top:4px;">Fit mode:</label>
        <select id="fit-mode">
          <option value="stretch">Stretch to fit</option>
          <option value="center">Center (no scale)</option>
          <option value="contain">Contain (keep aspect)</option>
        </select>
      </div>
    </div>

    <div class="panel">
      <h3>Help</h3>
      <p>
        <strong>Edit sprite:</strong><br>
        1. Open or drop a sprite PNG<br>
        2. Click &amp; drag to select a region<br>
        3. Click <strong>Replace Selection</strong> and pick a PNG<br>
        4. Export the result
      </p>
      <p style="margin-top:8px;">
        <strong>Build sprite:</strong><br>
        1. Click <strong>Add Images</strong> or <strong>Add Folder</strong><br>
        2. Adjust gap (padding) if needed<br>
        3. Click <strong>Generate Sprite</strong><br>
        4. Export the result
      </p>
    </div>
  </aside>

  <div class="canvas-container checkerboard" id="canvas-container">
    <canvas id="editor-canvas"></canvas>
    <div class="selection-box" id="selection-box"></div>
    <div class="selection-info" id="selection-info-tooltip"></div>

    <div class="empty-state" id="empty-state">
      <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
        <rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/>
        <path d="M21 15l-5-5L5 21"/>
      </svg>
      <p>Open or drag &amp; drop a sprite image</p>
      <p class="hint">Supports PNG files</p>
    </div>

    <div class="drop-overlay" id="drop-overlay">Drop image here</div>

    <div class="zoom-controls">
      <button class="btn" id="btn-zoom-out" title="Zoom out">-</button>
      <span class="zoom-label" id="zoom-label">100%</span>
      <button class="btn" id="btn-zoom-in" title="Zoom in">+</button>
      <button class="btn" id="btn-zoom-fit" title="Fit to view">Fit</button>
    </div>
  </div>
</div>

<div class="status-bar">
  <span id="status-cursor">0, 0</span>
  <span id="status-msg">Ready</span>
</div>

<input type="file" id="file-open" accept="image/png,image/*">
<input type="file" id="file-replace" accept="image/png,image/*">
<input type="file" id="file-add-images" accept="image/*" multiple>
<input type="file" id="file-add-folder" accept="image/*" webkitdirectory>

<script>
(() => {
  // --- State ---
  const state = {
    image: null,          // current HTMLImageElement of the sprite
    zoom: 1,
    panX: 0,
    panY: 0,
    // Selection in image-pixel coords
    sel: null,            // { x, y, w, h } or null
    selecting: false,
    selStart: null,
    // Undo/Redo stacks of ImageData
    undoStack: [],
    redoStack: [],
    // Panning
    panning: false,
    panStart: null,
    // Replacement preview
    replacementImg: null,
  };

  const MAX_UNDO = 40;

  // --- DOM refs ---
  const container = document.getElementById('canvas-container');
  const canvas = document.getElementById('editor-canvas');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const selBox = document.getElementById('selection-box');
  const selTooltip = document.getElementById('selection-info-tooltip');
  const emptyState = document.getElementById('empty-state');
  const dropOverlay = document.getElementById('drop-overlay');
  const zoomLabel = document.getElementById('zoom-label');
  const statusCursor = document.getElementById('status-cursor');
  const statusMsg = document.getElementById('status-msg');
  const spriteInfoEl = document.getElementById('sprite-info');
  const selInfoPanel = document.getElementById('selection-info-panel');
  const replaceInfoPanel = document.getElementById('replace-info-panel');
  const fitMode = document.getElementById('fit-mode');

  const btnOpen = document.getElementById('btn-open');
  const btnUndo = document.getElementById('btn-undo');
  const btnRedo = document.getElementById('btn-redo');
  const btnReplace = document.getElementById('btn-replace');
  const btnClearSel = document.getElementById('btn-clear-sel');
  const btnExport = document.getElementById('btn-export');
  const btnZoomIn = document.getElementById('btn-zoom-in');
  const btnZoomOut = document.getElementById('btn-zoom-out');
  const btnZoomFit = document.getElementById('btn-zoom-fit');
  const fileOpen = document.getElementById('file-open');
  const fileReplace = document.getElementById('file-replace');

  // --- Helpers ---
  function setStatus(msg) { statusMsg.textContent = msg; }

  function updateButtons() {
    const hasImage = !!state.image;
    const hasSel = !!state.sel;
    btnUndo.disabled = state.undoStack.length === 0;
    btnRedo.disabled = state.redoStack.length === 0;
    btnReplace.disabled = !(hasImage && hasSel);
    btnClearSel.disabled = !hasSel;
    btnExport.disabled = !hasImage;
  }

  function pushUndo() {
    const data = ctx.getImageData(0, 0, canvas.width, canvas.height);
    state.undoStack.push(data);
    if (state.undoStack.length > MAX_UNDO) state.undoStack.shift();
    state.redoStack = [];
    updateButtons();
  }

  function undo() {
    if (state.undoStack.length === 0) return;
    state.redoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
    const data = state.undoStack.pop();
    canvas.width = data.width;
    canvas.height = data.height;
    ctx.putImageData(data, 0, 0);
    updateButtons();
    setStatus('Undo');
  }

  function redo() {
    if (state.redoStack.length === 0) return;
    state.undoStack.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
    const data = state.redoStack.pop();
    canvas.width = data.width;
    canvas.height = data.height;
    ctx.putImageData(data, 0, 0);
    updateButtons();
    setStatus('Redo');
  }

  // --- Coordinate transforms ---
  function screenToImage(sx, sy) {
    const rect = container.getBoundingClientRect();
    const cx = sx - rect.left;
    const cy = sy - rect.top;
    const ix = (cx - state.panX) / state.zoom;
    const iy = (cy - state.panY) / state.zoom;
    return { x: ix, y: iy };
  }

  function imageToScreen(ix, iy) {
    return {
      x: ix * state.zoom + state.panX,
      y: iy * state.zoom + state.panY,
    };
  }

  // --- Rendering ---
  function render() {
    canvas.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
    canvas.style.transformOrigin = '0 0';
    zoomLabel.textContent = Math.round(state.zoom * 100) + '%';
    renderSelection();
  }

  function renderSelection() {
    if (!state.sel) {
      selBox.style.display = 'none';
      selBox.classList.remove('has-selection');
      selTooltip.style.display = 'none';
      return;
    }
    const s = state.sel;
    const tl = imageToScreen(s.x, s.y);
    const br = imageToScreen(s.x + s.w, s.y + s.h);
    const left = Math.min(tl.x, br.x);
    const top = Math.min(tl.y, br.y);
    const width = Math.abs(br.x - tl.x);
    const height = Math.abs(br.y - tl.y);

    selBox.style.display = 'block';
    selBox.classList.add('has-selection');
    selBox.style.left = left + 'px';
    selBox.style.top = top + 'px';
    selBox.style.width = width + 'px';
    selBox.style.height = height + 'px';

    // tooltip
    selTooltip.style.display = 'block';
    selTooltip.style.left = (left) + 'px';
    selTooltip.style.top = (top - 24) + 'px';
    selTooltip.textContent = `${Math.abs(s.w)} x ${Math.abs(s.h)} @ (${s.x}, ${s.y})`;
  }

  function updateSpriteInfo() {
    if (!state.image) {
      spriteInfoEl.innerHTML = '<p>No sprite loaded.</p>';
      return;
    }
    spriteInfoEl.innerHTML = `
      <div class="info-row"><span class="label">Width</span><span class="value">${canvas.width}px</span></div>
      <div class="info-row"><span class="label">Height</span><span class="value">${canvas.height}px</span></div>
    `;
  }

  function updateSelectionInfo() {
    if (!state.sel) {
      selInfoPanel.innerHTML = '<p>Click and drag on the canvas to select a region.</p>';
      return;
    }
    const s = state.sel;
    selInfoPanel.innerHTML = `
      <div class="info-row"><span class="label">Position</span><span class="value">${s.x}, ${s.y}</span></div>
      <div class="info-row"><span class="label">Size</span><span class="value">${s.w} x ${s.h}</span></div>
    `;
  }

  // --- Image loading ---
  function loadImage(file) {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      state.image = img;
      state.undoStack = [];
      state.redoStack = [];
      state.sel = null;
      state.replacementImg = null;
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
      emptyState.style.display = 'none';
      zoomToFit();
      updateSpriteInfo();
      updateSelectionInfo();
      updateButtons();
      setStatus(`Loaded ${file.name} (${img.naturalWidth}x${img.naturalHeight})`);
      URL.revokeObjectURL(url);
    };
    img.src = url;
  }

  function loadReplacement(file) {
    if (!state.sel) { setStatus('No selection to replace'); return; }
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      state.replacementImg = img;
      applyReplacement();
      URL.revokeObjectURL(url);
    };
    img.src = url;
  }

  function applyReplacement() {
    if (!state.sel || !state.replacementImg) return;
    const s = state.sel;
    const img = state.replacementImg;
    const mode = fitMode.value;

    pushUndo();

    // Clear the selection region
    ctx.clearRect(s.x, s.y, s.w, s.h);

    ctx.save();
    ctx.beginPath();
    ctx.rect(s.x, s.y, s.w, s.h);
    ctx.clip();

    if (mode === 'stretch') {
      ctx.drawImage(img, s.x, s.y, s.w, s.h);
    } else if (mode === 'center') {
      const dx = s.x + Math.floor((s.w - img.naturalWidth) / 2);
      const dy = s.y + Math.floor((s.h - img.naturalHeight) / 2);
      ctx.drawImage(img, dx, dy);
    } else if (mode === 'contain') {
      const scale = Math.min(s.w / img.naturalWidth, s.h / img.naturalHeight);
      const dw = img.naturalWidth * scale;
      const dh = img.naturalHeight * scale;
      const dx = s.x + (s.w - dw) / 2;
      const dy = s.y + (s.h - dh) / 2;
      ctx.drawImage(img, dx, dy, dw, dh);
    }

    ctx.restore();

    // Update replacement info panel with thumbnail
    replaceInfoPanel.innerHTML = `
      <p style="font-size:12px;color:#aaa;">Replacement applied (${img.naturalWidth}x${img.naturalHeight})</p>
      <img class="preview-thumb" src="${img.src}" alt="replacement preview">
      <label for="fit-mode" style="font-size:12px;color:#888;margin-top:4px;">Fit mode:</label>
      <select id="fit-mode" onchange="document.getElementById('fit-mode').dispatchEvent(new Event('change'))">
        <option value="stretch" ${mode === 'stretch' ? 'selected' : ''}>Stretch to fit</option>
        <option value="center" ${mode === 'center' ? 'selected' : ''}>Center (no scale)</option>
        <option value="contain" ${mode === 'contain' ? 'selected' : ''}>Contain (keep aspect)</option>
      </select>
    `;

    setStatus('Replaced selection');
    updateButtons();
  }

  // --- Zoom / Pan ---
  function zoomToFit() {
    if (!state.image) return;
    const cw = container.clientWidth;
    const ch = container.clientHeight;
    const iw = canvas.width;
    const ih = canvas.height;
    const padding = 40;
    const scale = Math.min((cw - padding * 2) / iw, (ch - padding * 2) / ih, 8);
    state.zoom = scale;
    state.panX = (cw - iw * scale) / 2;
    state.panY = (ch - ih * scale) / 2;
    render();
  }

  function zoomAt(factor, cx, cy) {
    const rect = container.getBoundingClientRect();
    const mx = cx - rect.left;
    const my = cy - rect.top;
    const oldZoom = state.zoom;
    state.zoom = Math.min(64, Math.max(0.1, state.zoom * factor));
    const ratio = state.zoom / oldZoom;
    state.panX = mx - (mx - state.panX) * ratio;
    state.panY = my - (my - state.panY) * ratio;
    render();
  }

  // --- Event handlers ---

  // File open
  btnOpen.addEventListener('click', () => fileOpen.click());
  fileOpen.addEventListener('change', e => {
    if (e.target.files[0]) loadImage(e.target.files[0]);
    e.target.value = '';
  });

  // Replace
  btnReplace.addEventListener('click', () => fileReplace.click());
  fileReplace.addEventListener('change', e => {
    if (e.target.files[0]) loadReplacement(e.target.files[0]);
    e.target.value = '';
  });

  // Undo / Redo
  btnUndo.addEventListener('click', undo);
  btnRedo.addEventListener('click', redo);

  // Clear selection
  btnClearSel.addEventListener('click', () => {
    state.sel = null;
    state.replacementImg = null;
    renderSelection();
    updateSelectionInfo();
    updateButtons();
    replaceInfoPanel.innerHTML = `
      <p>Select a region first, then click <strong>Replace Selection</strong> to load a replacement image.</p>
      <label for="fit-mode" style="font-size:12px;color:#888;margin-top:4px;">Fit mode:</label>
      <select id="fit-mode">
        <option value="stretch">Stretch to fit</option>
        <option value="center">Center (no scale)</option>
        <option value="contain">Contain (keep aspect)</option>
      </select>
    `;
    setStatus('Selection cleared');
  });

  // Export
  btnExport.addEventListener('click', () => {
    const a = document.createElement('a');
    a.download = 'sprite-export.png';
    a.href = canvas.toDataURL('image/png');
    a.click();
    setStatus('Exported sprite as PNG');
  });

  // Zoom buttons
  btnZoomIn.addEventListener('click', () => {
    const rect = container.getBoundingClientRect();
    zoomAt(1.25, rect.left + rect.width / 2, rect.top + rect.height / 2);
  });
  btnZoomOut.addEventListener('click', () => {
    const rect = container.getBoundingClientRect();
    zoomAt(0.8, rect.left + rect.width / 2, rect.top + rect.height / 2);
  });
  btnZoomFit.addEventListener('click', zoomToFit);

  // Mouse: selection and panning
  container.addEventListener('mousedown', e => {
    if (e.target.closest('.zoom-controls')) return;
    if (!state.image) return;

    // Middle click or space+click = pan
    if (e.button === 1 || (e.button === 0 && e.altKey)) {
      state.panning = true;
      state.panStart = { x: e.clientX - state.panX, y: e.clientY - state.panY };
      container.style.cursor = 'grabbing';
      e.preventDefault();
      return;
    }

    if (e.button !== 0) return;

    // Start selection
    const p = screenToImage(e.clientX, e.clientY);
    const ix = Math.max(0, Math.min(canvas.width, Math.round(p.x)));
    const iy = Math.max(0, Math.min(canvas.height, Math.round(p.y)));
    state.selecting = true;
    state.selStart = { x: ix, y: iy };
    state.sel = { x: ix, y: iy, w: 0, h: 0 };
    state.replacementImg = null;
    renderSelection();
    updateSelectionInfo();
    updateButtons();
  });

  window.addEventListener('mousemove', e => {
    if (!state.image) return;

    // Update cursor position
    const p = screenToImage(e.clientX, e.clientY);
    const ix = Math.round(p.x);
    const iy = Math.round(p.y);
    statusCursor.textContent = `${ix}, ${iy}`;

    if (state.panning) {
      state.panX = e.clientX - state.panStart.x;
      state.panY = e.clientY - state.panStart.y;
      render();
      return;
    }

    if (state.selecting) {
      const px = Math.max(0, Math.min(canvas.width, Math.round(p.x)));
      const py = Math.max(0, Math.min(canvas.height, Math.round(p.y)));
      const sx = Math.min(state.selStart.x, px);
      const sy = Math.min(state.selStart.y, py);
      const sw = Math.abs(px - state.selStart.x);
      const sh = Math.abs(py - state.selStart.y);
      state.sel = { x: sx, y: sy, w: sw, h: sh };
      renderSelection();
      updateSelectionInfo();

      // Show live selection box while dragging
      const tl = imageToScreen(sx, sy);
      const br = imageToScreen(sx + sw, sy + sh);
      selBox.style.display = 'block';
      selBox.classList.remove('has-selection');
      selBox.style.left = tl.x + 'px';
      selBox.style.top = tl.y + 'px';
      selBox.style.width = (br.x - tl.x) + 'px';
      selBox.style.height = (br.y - tl.y) + 'px';
      selBox.style.borderStyle = 'dashed';
    }
  });

  window.addEventListener('mouseup', e => {
    if (state.panning) {
      state.panning = false;
      container.style.cursor = 'crosshair';
      return;
    }
    if (state.selecting) {
      state.selecting = false;
      // Discard tiny selections
      if (state.sel && (state.sel.w < 2 || state.sel.h < 2)) {
        state.sel = null;
      }
      selBox.style.borderStyle = 'solid';
      renderSelection();
      updateSelectionInfo();
      updateButtons();
      if (state.sel) {
        setStatus(`Selected ${state.sel.w}x${state.sel.h} at (${state.sel.x}, ${state.sel.y})`);
      }
    }
  });

  // Wheel zoom
  container.addEventListener('wheel', e => {
    if (!state.image) return;
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
    zoomAt(factor, e.clientX, e.clientY);
  }, { passive: false });

  // Drag & drop
  container.addEventListener('dragenter', e => { e.preventDefault(); dropOverlay.classList.add('visible'); });
  container.addEventListener('dragover', e => { e.preventDefault(); });
  container.addEventListener('dragleave', e => {
    if (!container.contains(e.relatedTarget)) dropOverlay.classList.remove('visible');
  });
  container.addEventListener('drop', e => {
    e.preventDefault();
    dropOverlay.classList.remove('visible');
    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith('image/')) {
      if (state.image && state.sel) {
        loadReplacement(file);
      } else {
        loadImage(file);
      }
    }
  });

  // Keyboard
  window.addEventListener('keydown', e => {
    if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
    if (e.ctrlKey && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) { e.preventDefault(); redo(); }
    if (e.key === 'Escape') {
      state.sel = null;
      state.replacementImg = null;
      renderSelection();
      updateSelectionInfo();
      updateButtons();
    }
    if (e.key === '0') zoomToFit();
    if (e.key === '=' || e.key === '+') {
      const rect = container.getBoundingClientRect();
      zoomAt(1.25, rect.left + rect.width / 2, rect.top + rect.height / 2);
    }
    if (e.key === '-') {
      const rect = container.getBoundingClientRect();
      zoomAt(0.8, rect.left + rect.width / 2, rect.top + rect.height / 2);
    }
    // Delete selection content
    if (e.key === 'Delete' && state.sel && state.image) {
      pushUndo();
      ctx.clearRect(state.sel.x, state.sel.y, state.sel.w, state.sel.h);
      setStatus('Cleared selection content');
    }
  });

  // Fit mode change - re-apply if replacement is loaded
  fitMode.addEventListener('change', () => {
    if (state.replacementImg && state.sel) {
      // Re-apply with new fit mode. Undo the previous replacement first.
      if (state.undoStack.length > 0) {
        const prev = state.undoStack.pop();
        canvas.width = prev.width;
        canvas.height = prev.height;
        ctx.putImageData(prev, 0, 0);
      }
      applyReplacement();
    }
  });

  // Window resize
  window.addEventListener('resize', () => { if (state.image) render(); });

  // --- Sprite Builder ---
  const builderImages = [];   // { name, fileName, el, width, height, url }
  let builderLastResult = null;

  const btnAddImages = document.getElementById('btn-add-images');
  const btnAddFolder = document.getElementById('btn-add-folder');
  const btnGenerate = document.getElementById('btn-generate');
  const btnExportCss = document.getElementById('btn-export-css');
  const btnBuilderClear = document.getElementById('btn-builder-clear');
  const fileAddImages = document.getElementById('file-add-images');
  const fileAddFolder = document.getElementById('file-add-folder');
  const builderListEl = document.getElementById('builder-list');
  const builderInfoEl = document.getElementById('builder-info');
  const builderPadding = document.getElementById('builder-padding');

  function addBuilderFiles(fileList) {
    const toLoad = [];
    for (const f of fileList) {
      if (f.type.startsWith('image/') || /\.(png|jpe?g|gif|webp|bmp|svg)$/i.test(f.name)) {
        toLoad.push(f);
      }
    }
    if (!toLoad.length) return;
    let loaded = 0;
    toLoad.forEach(file => {
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => {
        builderImages.push({
          name: file.name.replace(/\.[^.]+$/, ''),
          fileName: file.name,
          el: img,
          width: img.naturalWidth,
          height: img.naturalHeight,
          url,
        });
        if (++loaded === toLoad.length) {
          builderImages.sort((a, b) => a.fileName.localeCompare(b.fileName, undefined, { numeric: true }));
          updateBuilderUI();
          setStatus(`Added ${toLoad.length} image${toLoad.length > 1 ? 's' : ''} to builder`);
        }
      };
      img.onerror = () => {
        URL.revokeObjectURL(url);
        if (++loaded === toLoad.length) updateBuilderUI();
      };
      img.src = url;
    });
  }

  function updateBuilderUI() {
    btnGenerate.disabled = builderImages.length === 0;
    btnBuilderClear.disabled = builderImages.length === 0;
    btnExportCss.disabled = !builderLastResult;
    if (builderImages.length === 0) {
      builderListEl.innerHTML = '<p style="font-size:12px;color:#555;">Add images using the toolbar buttons.</p>';
      builderInfoEl.textContent = '';
      return;
    }
    let html = '';
    builderImages.forEach((img, i) => {
      html += `<div class="builder-item">
        <img src="${img.url}" class="builder-thumb" alt="">
        <div class="builder-item-info">
          <span class="builder-item-name" title="${img.fileName}">${img.name}</span>
          <span class="builder-item-size">${img.width}\u00d7${img.height}</span>
        </div>
        <button class="builder-item-remove" data-idx="${i}">\u00d7</button>
      </div>`;
    });
    builderListEl.innerHTML = html;
    builderListEl.querySelectorAll('.builder-item-remove').forEach(btn => {
      btn.addEventListener('click', () => {
        const idx = parseInt(btn.dataset.idx);
        URL.revokeObjectURL(builderImages[idx].url);
        builderImages.splice(idx, 1);
        builderLastResult = null;
        updateBuilderUI();
      });
    });
    builderInfoEl.textContent = `${builderImages.length} image${builderImages.length !== 1 ? 's' : ''}`;
  }

  btnAddImages.addEventListener('click', () => fileAddImages.click());
  btnAddFolder.addEventListener('click', () => fileAddFolder.click());
  fileAddImages.addEventListener('change', e => { if (e.target.files.length) addBuilderFiles(e.target.files); e.target.value = ''; });
  fileAddFolder.addEventListener('change', e => { if (e.target.files.length) addBuilderFiles(e.target.files); e.target.value = ''; });
  btnBuilderClear.addEventListener('click', () => {
    builderImages.forEach(img => URL.revokeObjectURL(img.url));
    builderImages.length = 0;
    builderLastResult = null;
    updateBuilderUI();
  });

  // --- MaxRects Bin Packing (Best Short Side Fit) ---
  class MaxRectsBin {
    constructor(w, h) { this.free = [{ x: 0, y: 0, w, h }]; }

    insert(w, h) {
      let bestSS = Infinity, bestLS = Infinity, best = null;
      for (const f of this.free) {
        if (w <= f.w && h <= f.h) {
          const ss = Math.min(f.w - w, f.h - h);
          const ls = Math.max(f.w - w, f.h - h);
          if (ss < bestSS || (ss === bestSS && ls < bestLS)) {
            bestSS = ss; bestLS = ls;
            best = { x: f.x, y: f.y, w, h };
          }
        }
      }
      if (!best) return null;
      this._split(best);
      this._prune();
      return best;
    }

    _split(r) {
      const next = [];
      for (let i = this.free.length - 1; i >= 0; i--) {
        const f = this.free[i];
        if (r.x >= f.x + f.w || r.x + r.w <= f.x || r.y >= f.y + f.h || r.y + r.h <= f.y) continue;
        this.free.splice(i, 1);
        if (r.x > f.x) next.push({ x: f.x, y: f.y, w: r.x - f.x, h: f.h });
        if (r.x + r.w < f.x + f.w) next.push({ x: r.x + r.w, y: f.y, w: f.x + f.w - r.x - r.w, h: f.h });
        if (r.y > f.y) next.push({ x: f.x, y: f.y, w: f.w, h: r.y - f.y });
        if (r.y + r.h < f.y + f.h) next.push({ x: f.x, y: r.y + r.h, w: f.w, h: f.y + f.h - r.y - r.h });
      }
      this.free.push(...next);
    }

    _prune() {
      for (let i = this.free.length - 1; i >= 0; i--) {
        const a = this.free[i];
        for (let j = 0; j < this.free.length; j++) {
          if (i === j) continue;
          const b = this.free[j];
          if (a.x >= b.x && a.y >= b.y && a.x + a.w <= b.x + b.w && a.y + a.h <= b.y + b.h) {
            this.free.splice(i, 1);
            break;
          }
        }
      }
    }
  }

  function findOptimalPacking(images, padding) {
    if (images.length === 0) return null;
    if (images.length === 1) {
      return { width: images[0].width, height: images[0].height, placements: [{ x: 0, y: 0 }] };
    }

    const rects = images.map((img, i) => ({ i, w: img.width + padding, h: img.height + padding }));
    const sorted = [...rects].sort((a, b) => {
      const ma = Math.max(a.w, a.h), mb = Math.max(b.w, b.h);
      return mb !== ma ? mb - ma : b.w * b.h - a.w * a.h;
    });

    const totalArea = rects.reduce((s, r) => s + r.w * r.h, 0);
    const maxW = Math.max(...rects.map(r => r.w));
    const sumH = rects.reduce((s, r) => s + r.h, 0);
    const sqrtA = Math.ceil(Math.sqrt(totalArea));

    let best = null, bestArea = Infinity;
    const step = Math.max(1, Math.floor((sqrtA * 3 - maxW) / 80));
    const widths = new Set();
    for (let w = maxW; w <= sqrtA * 3; w += step) widths.add(w);
    [0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.5, 2, 2.5, 3].forEach(m => widths.add(Math.ceil(sqrtA * m)));
    widths.add(rects.reduce((s, r) => s + r.w, 0)); // horizontal strip

    for (const tryW of widths) {
      if (tryW < maxW) continue;
      const bin = new MaxRectsBin(tryW, sumH);
      let ok = true;
      const pl = new Array(images.length);
      for (const r of sorted) {
        const p = bin.insert(r.w, r.h);
        if (!p) { ok = false; break; }
        pl[r.i] = { x: p.x, y: p.y };
      }
      if (!ok) continue;
      const bw = Math.max(...pl.map((p, i) => p.x + images[i].width));
      const bh = Math.max(...pl.map((p, i) => p.y + images[i].height));
      if (bw * bh < bestArea) {
        bestArea = bw * bh;
        best = { width: bw, height: bh, placements: pl };
      }
    }
    return best;
  }

  btnGenerate.addEventListener('click', () => {
    if (builderImages.length === 0) return;
    const padding = parseInt(builderPadding.value) || 0;
    setStatus('Packing sprites\u2026');

    setTimeout(() => {
      const result = findOptimalPacking(builderImages, padding);
      if (!result) { setStatus('Packing failed'); return; }

      state.undoStack = [];
      state.redoStack = [];
      state.sel = null;
      state.replacementImg = null;

      canvas.width = result.width;
      canvas.height = result.height;
      ctx.clearRect(0, 0, result.width, result.height);
      result.placements.forEach((p, i) => {
        ctx.drawImage(builderImages[i].el, p.x, p.y);
      });

      const img = new Image();
      img.src = canvas.toDataURL('image/png');
      state.image = img;

      emptyState.style.display = 'none';
      zoomToFit();
      updateSpriteInfo();
      updateSelectionInfo();
      updateButtons();
      builderLastResult = result;
      updateBuilderUI();
      setStatus(`Generated ${result.width}\u00d7${result.height} sprite from ${builderImages.length} images`);
    }, 10);
  });

  // --- Export CSS ---
  function sanitizeCssName(name) {
    return name.replace(/[^a-zA-Z0-9_-]/g, '-').replace(/^-*\d/, '_$&').replace(/-+/g, '-');
  }

  btnExportCss.addEventListener('click', () => {
    if (!builderLastResult || builderImages.length === 0) return;
    const r = builderLastResult;
    let css = '/* Generated by Sprite Builder */\n';
    css += `.sprite {\n  display: inline-block;\n  background-image: url('sprite-export.png');\n  background-repeat: no-repeat;\n}\n\n`;
    r.placements.forEach((p, i) => {
      const img = builderImages[i];
      const cls = sanitizeCssName(img.name);
      css += `.sprite-${cls} {\n  width: ${img.width}px;\n  height: ${img.height}px;\n  background-position: -${p.x}px -${p.y}px;\n}\n`;
    });
    const blob = new Blob([css], { type: 'text/css' });
    const a = document.createElement('a');
    a.download = 'sprite-export.css';
    a.href = URL.createObjectURL(blob);
    a.click();
    URL.revokeObjectURL(a.href);
    setStatus('Exported sprite CSS');
  });

  updateBuilderUI();

  // Init
  render();
  updateButtons();
})();
</script>
</body>
</html>
